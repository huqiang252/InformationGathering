#!/usr/bin/env python
# -*- coding: utf-8 -*-
# @Author  : qiang.hu
# @Time: 2024-06-20


# 1.工具类
'''
概念： 负责具体实现的类，工具类的对象被业务类的方法调用。  他不主动做事，只在业务类需要他干活的时候干活

工具类的作用：
1. 增加现有的库的功能
2. 简化现有的库的接口


（1）增加库的功能

场景：系统提供的http api采用token鉴权， 但是出于安全考虑,token会每隔15分钟过期

使用封装的RestClient工具类
    可以在每个请求收到响应后，都去检查是否遇到tocken过期问题，如果遇到就用当前tocken调用refresh_tocken接口，然后重新调用刚才出错的接口


(2) 简化库接口
实现一个工具类
    1.可以屏蔽掉其他写法，提供统一且唯一的get请求发送方式
    2.可以非常有效解决维护等各种问题

'''

# 2.业务类的使用
'''
业务类主要作用：
    封装现有业务，提供统一的调用入口
    屏蔽工具类的实现细节，让关注业务的读者不用看具体实现
    
封装现有业务
    例如，jenkins有很多功能，我们用jenkins的业务类把这些功能封装成方法。之后不管是哪个角色的用户要用哪个功能，都直接调用jenkins类的对应方法


屏蔽实现细节
    当我们要用jenkins类要实现一些业务的时候，很可能我们不想了解技术细节。比如创建job
    假设jenkins类有一个create_job方法，需要传的参数有a,b,c,d,e;那么我们把这几个参数传给业务类create_job方法，剩下都是业务类自己去做的事情
    业务类会自己和工具类打交道，去和底层要用的库打交道
    假设有一天底层库request库更改了urllib3，那么又有什么关系，只要create_job需要的参数没改的话，我们的调用业务类写的代码就不用改

'''

##3.工具类和业务类的辩证统一
'''
工具类和业务类都可以不是绝对的 
    例子：DBManager类除了数据库读写操作，还添加了存取yaml文件的方法，这两个方法属于业务方法
    每个类的内部可以分（业务层+工具层）
    随着类的代码越来越多，一个类的业务层和实现层可以拆分成独立的工具类和业务类=常用的代码重构方法
'''

##4.更加多的业务类和工具类
'''
数据结构类：封装一个类来代表复杂的数据结构，如Response类

工具类：封装一个类来实现与业务无关的特定功能，如MyLog类，RestClient类等

业务类：分为 接口封装类 和  具体工具类
    --接口封装类：如Jenkins类 用例封装具体http接口的方法，也可以用来封装其他协议的接口，放在接口封装类中，如run_groovy
    --具体业务类，如JenkinsOperation类，用来封装这个业务的各种业务方法，如create_job_with_dsl
工具方法： 单独实现特定功能的方法，通常和业务无关，如clear_log

'''