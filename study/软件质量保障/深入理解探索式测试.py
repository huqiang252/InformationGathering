#!/usr/bin/env python
# -*- coding: utf-8 -*-
# @Author  : qiang.hu
# @Time: 2024-06-22
##第一部分:奠定基础
'''
（1）关于测试和探索
测试的本质 = 设计一个试验以便收集经验证据，由此解答和风险相关的问题
两个核心问题的测试策略：
    1.面对其理应处理的情况，软件的表现是否符合预期？
        检查
    2.是否存在其他风险？
        探索（要想发现额外惊喜，重复性帮不了你，而变化可以）

已测试 = 已检查 + 已探索

探索式测试基本要素：
    设计测试
        找出值得关注的可变事物，并找出有意义的方法使他们发生变化
    执行
        立即执行（不需要等到设计完所有用例之后开始执行）
    学习
        发现软件如何运转，可以从中了解它的怪癖，恶习
    指导
        你迄今为止已知晓的一切，将为你指出有待发掘的下一个最相关的信息片段

限时探测回话开展工作
    v：基于探测的测试管理SBTM
    action: 记录
        测试思路
        问题
        风险
        惊喜
        其他领域


(2)为探索制定探索章程
简单的探测章程模板
    探索
        探索何处，可能是特性，需求，模块
    使用
        什么资源，一切皆资源：某个工具，数据集，技术，配置或者某个相互依赖的特性
    以图发现
        你希望找到那种信息？

(3)观察细节
    好观察
        透过所期的或所希望找到事物的真实情况
            不能停留在表面，一定要深入幕后。
                控制台
                日志
                监控程序
                私有接口控制应用程序


    可测试性 与 让不可见变可见
        方法如下
            用监控操作系统的监视器（mac活动监视，windows进程监视器）
            自己写小脚本监视文件系统活动，在文件系统里面，创建，修改或删除文件
            可以观察网络流程
            基于web的系统，使用一些插件，如firebug,f12
            关系型数据库系统，专门为那些测试相关数据建表
                安装监视器，为关键数据表设置触发器


（3）找出有意义的变化
变量就是会变化的事物
    特别要找：影响系统行为的变量

    变量
        明显的变量
        微妙变量
        间接地访问的变量


识别变量
    可计数之物
        0,1,多
            让搜索返回0条，1条，或多条记录
        过多
            制造出数量超额的状况
        过少
            制造出数量低于预期的状态让软件处理
    相对位置
        开头--中间--结尾
    文件和存储
    地理位置
    格式
    大小
    深度
        HTML解析器，4级嵌套
        算式深度
    时间点，频率和持续时间
        时间点和用户动作向来都是变量
    输入和导航


（4）评估结果
    绝不和始终
        所做的探索导致系统违背了某条“原则”
            绝不
            始终
        核心功能：如果系统的其他功能都不工作，有什么是绝对肯定必须正常运转？
        质量因子
            准确性
            可靠性
            可用性
            易用性
            可达性
            安全性
        风险

    替代资源
        内在一致性
            系统用户理所当然会期待它具有一致性
        标准
            带GUI,参照苹果，微软发布的UI指南
            通信协议参考IEEE发布的IPV6,DHCP标准
            web程序参照w3c发布的web标准
            安全性的软件参照OWASP发布的开发指南
        对比
            把其他相似或相关软件当做参考点
        近似
            参照范围评估
                输入数据其结果是否在合理性范围
            评估特征
            结果反转
                判断结果是否正确就是针对结果执行反向操作
'''


##2.增加维度
'''
(1)改变顺序和交互
    名称和动词
        把系统的名称和动词识别出来
        随机的选择动词和名词，进行组合
            不合逻辑的顺序也能促成你进行有创造性的诠释
        注意观察不合预期行为的蛛丝马迹，特别留意那些违背了系统的”始终“和”绝不“的现象
    随机导航
        探索时，要特别留意针对这些种类的动作挑选不同的机制进行探索
            哪些方法可以关闭当前窗口？
            哪些方法可以从当前位置返回到前一个窗口或视图
            哪些方法可以把数据输入某个指定字段
            哪些方法可以提交或保存修改
            哪些方法可以取消或重做某个动作？
        记录下可完成相同动作的所有方法
    角色任务
        设身处地像角色人物那样思考，在探索软件是，要模仿他们的个性特征，意图和担忧

（2）探索实体及实体之间的关系
    识别实体，属性，依赖
        寻找不明显的实体
            留意一些对系统而不是对用户更为可见的实体
                如：登入系统，通常生成会话，会话本身就是实体
            寻找GUI表单
                任何时候需要向某个表单的字段填入数据，很可能就是在创建或更新某种种类的实体
            通过识别属性来识别实体
                例如：位置，大小，颜色这些格式的选项，都是能提升你发现另外一种实体的好线索
                
    绘制关系图
        可以使用实体关系图ERD来描述这些链接的本质
        为系统中的实体绘制关系图时，远比简单一对多关系复杂
        
    CRUD:创建，读取，更新，删除
        数据变量的CRUD
            在创建实体是，把所有可选字段都填上，再删除这些字段的值，并尝试进行更新操作
        其他CRUD方法
            比较不同的方式所创建的实体，他们的属性或者行为有何差异
        零，单，多依赖的CRUD
            可以尝试删除供应商最后一条项，制造供应商只有0条情况
            也可以制造有且仅有一条选项，而该该条项有且仅有一家供应商
    跟随数据
        留意因采取行动而导致系统中某区域受副作用影响的迹象
            观察控制台
            日志
            
（3）发现状态和转换
学会绘制一个状态模型和使用启发法以暴露这些跟时间相关的惊喜
    找出状态和事件
        状态是行为的模式
            有没有什么事情是我现在可以做但之前不能做
            有没有什么现在能做之前不能做的
            我现在采取的行动产生了和之前不同的结果？
            自己用于描述正在发送事情的言语，也能把状态测测出来，留意自己描述软件用 “当..."
                当系统正在导入数据的时候。。。
                当系统正在运行报表的时候。。。
                当系统正在结算的时候。。。
                。。
        
        事件触发状态转换
            用户操作
                在GUI页面点击某个操作
                通过命令执行一条命令
            外部产生事件
                软件之外的任何事件
            系统产生事件
                软件自己产生的任何事件，通常都是系统为了完成某些后台活动而产生的结果
            时间流逝
                超时的事件，留意那些在特定时长之后才会出现的情形
                同样也要留意那些专在特定时间出现的事件
                    例如：某个设定于每日午夜执行的备份操作
                    
        绘制状态模型图
            创建状态模型，只发现状态和事件远远不够，用不了多久这活儿就变得非常困难
            
            专注
                选择一个关注对象很重要，不然遭到分析麻痹症侵袭
            确定一个角度
                从某个角度来绘制状图，所选视角会指出哪些状态和事件属于该版图，从而收窄了范围
                
            高低调拨抽象层级
                针对更为庞大的目标，就得从更高的抽象层级进行建模
    
    
    
    探索状态模型
        所有路径
            寻找从某个状态进入另外一个状态的所有路径
            考虑这些问题
                有哪些方式可以把关闭变成开启
                有哪些方式从开启变成关闭
        干扰
            触发以外事件干扰了某个状态时候，软件能不能做出合理的响应
                点击用户控件
                登出
                让会话超时
                杀掉进程
                关闭笔记本电脑的屏幕
                拨动机器上的开关
                给机器断开网络
        变量重提
            结合其他变量，比如状态或事件相关变量的配置项设置，输入，输出
            
    
    
    改变其呈现：状态表格
        圆圈和箭头来描绘状态模式
            状态模式提示你要思考转换    
        可以把状态和事件放入表格
            状态表格则提示你要思考
            
            
（4）探索生态系统
    绘制生态系统图
        语境图
            软件和系统外部世界的链接一起方式
                接口，用户
                集成系统间的链接 
        部署图
            展示构建系统的那些组件
                数据库
                配置文件
                可执行文件
                
        操作步骤
            第一步：画接口
                把软件使用者放在系统外部
                    用户接口标出来，跟人连起来
            第二部：绘出外部依赖
                网关
                数据源
                接收端系统
            第三部：充填内部
                把存储用户数据的关系型数据库给写上了，因为探索生产系统数据的变化是非常非常必要的
        避免分析麻痹症
            要处理一个没有参与设计的系统，想要找出所有依赖就会是一件很有压力的事儿。
            
    信任边界
        从探索的角度，系统你可以控制的每个点都存在一个信任边界
            数据库
            文件系统
            网络连接
        破坏信任
            输入非法数据
            已破坏文档
            执行超出系统预期的操作
    如果的话
        使用“如果的话”的技巧，需要走查整个生态系统图，并思考如下问题
            如果链接断了会怎样
            如果链接对端的服务无响应会怎样
            如果网络太慢导致请求超时，没有收到响应会怎样
            如果文件缺失会怎样？
        操作
            网络连接
                断开
                把系统拿一部分放在防火墙或网段的另一边
                降低网速
        文件
            删除文件
            损坏文件内容
            用空文件覆盖它
            把文件弄得非常大
            配置软件对网络上某个远程驱动器的文件读写操作
            把文件变成只读的
            移除文件的所有权限
            
    跟随数据
'''


##3.结合场景
'''
(1)没有用户接口的探索
服务器，API,嵌入式系统，批处理程序这些系统没有图形界面
    探索API
        编写小程序，调用函数并返回结果
            识别可变化事物
            0,1,多
    探索编程语言
        探索不只适用于产品代码。构建代码所依赖的那些技术，探索技术同样可以帮助你去理解他们的能力范围和局限所在
    探索web服务
        不管探索是何种事物，不管它是何种接口，你都能找到可变化的有趣之处
        
    细究BUG
        适用于GUI那些分析方法，可以在系统用上，将试验设计为设计不同的数字，大小，频率以及请求的时间点

（2）探索现存系统
背景：如何以结构化的方式运用探索技术，探寻现有系统的能力和局限
    侦查探测会话打头
        需要回答如下问题
            它能做什么？
            它怎么接受输入？
            它怎么（或在何处）产生输出？
            一个简单的输入或动作序列是怎样的，而期对应的输出或结果又是什么？
            环境或配置是怎样影响输出的
            有没有什么办法可以绕开预设的公共接口和系统交互？
            怎么触发出错情况
            如果不按规定使用或者刻意地触发出错情况的话，会发生什么样的事情呢？
    分享观察结果
        汇集各方见解，能更有效地利用大家的时间
    采访干系人以收集问题
        交谈过程中，如果他人提到了你尚未探索过的，就要把他们记录下来
    选择技术
        使用启发法（0,1，多，部分，全无，全部，开始，中间，结束），只不过你并非为了寻找深藏的BUG，而是为了更好的理解系统以便预测你的行动将会产生的影响
            如果系统对时间敏感，使用 发现状态和转换
            如果执行操作的顺序可以改变，使用 改变顺序和交互
            如果系统严重依赖数据，使用 探索实体及实体之间的关系
            如果系统和其他系统有广泛的交互 使用  探索生态系统
    记录调查结果
        文档不充分才需要靠自己描绘系统
            选用一个支持以表格形式书写测试的功能测试自动化框架，实现这些实例的自动化执行
                如果相关操作序列可用于多个测试，那么它们很快就能看到回报
            简短的测试集
                内容：代表系统核心功能的可重复的冒烟测试或者回归测试
                轻量化：记录下来（不需要事无巨细的说明书，能在较高层次把握每个测试的精髓即可）
            测试列表
                自动化回归实现的切入点
                代码更新之后的需要检查的事项清单
    如何处理恐怖的不可重现的BUG
        关键
            意识到，发现控制影响其行为的所有变量，然后缺陷都是绝对100%重现
        收集证据
            日志文件
            屏幕截图
            输入数据
            控制台错误
        绞尽脑汁想出嫌疑变量
            罗列你认为可能会影响其行为的所有变量
        使用状态模型以理解时间设置
        协作
        
(3)探索需求
    进入需求会议
        需要听到第一手的交谈，你们的团队也需要带去的探索心态
    被遗忘有问题
    一对一讨论带来误解
    测试评审变成了需求评审
        诀窍：带上饼干，带着巧克力（渗入他们的队伍）
    需求会议中
        发现关键价值
            业务干系人讲话的时候，你要边听做记录。留意其中的核心特性和能力，你需要围绕他们进行深入探索
        询问“如果的话”
            需要能抽出某个实现方案的主体思想，立即在脑海中罗列可用的测试用例
            从中选择出“最有意义或最相关的那些用例”
        调整期望值
            没有早点跟团队期待的话，如果团队决定，根据你找到的信息采取行动，那么项目会延迟；如果他们不采取行动，那就是浪费你的时间
            
    
    需求讨论过程中写下探索章程
        探索：
            探索xx特性
            使用xx资源
            以图发现信息
            
        通过问这些问题校准探测章程，可以节省你在干系人不关心的软件边界进行探索的时间
        
    积极阅读
        质问文件
            如果的话，发现关于系统某些东西必须为真的陈述，考虑他为假会怎样
        分解
            积极阅读需求文档模型：
                输入：软件接收或吸纳的任何东西
                输出：系统产生的任何东西 ，可能是报告，发送用户的信息，在控制台或日志里的消息，甚至是有系统另一部分所消耗的事件
                处理：描述系统如何将输入变成输出的任何东西。可以在 算法，软件幕后动作，对临时数据的引入
                问题：所激发出的问题灵感
        绘制模型
            状态图
            语境图（生态系统)
            



            
(4)整合探索，融会贯通
    在测试策略中包含探索
        如果我们的测试策略囊括了检查和探索，而且团队也会根据测试所揭示的信息采取行动--->高质量软件
    开发全程整合检查和探索
        团队工作的每一步都有检查。
            检查意味着软件一直处于可探索的状态
        早探索，多探索
            在需求阶段就可以探索了
            任何时候只要有一行签入了源代码控制系统，就可以开始探索它的行为了
        致力于探索
            探索打从最开始就已经是其流程的一部分了，放在第一位优先考虑的活动
        结对探索
    发现问题的系统性根源
        如果探索发现非常多问题，就不只是软件坏了，流程本身也坏掉了
    
    估算探索
        建议不要把探索式测试单独拆开来估时间，直接估算开发整体耗时就可以了
    
    如何得知探索已充分
        探索已解答所有未知问题
        学不到新东西
        增多信息不会带来任何改变
        
    向干系人汇报
    -因为对探测章程和探测会话来说根本没有成功和失败的概念
        在每日站会进行报告
            举例：昨天使用畸形数据对导入功能进行探索。我发现，只要导入空文件，就会导致进程死掉。处理批次中的剩余文件也不会被处理。我已经提交了一个bug
            今天打算继续探索畸形数据，感觉应该还会有其他相关联的问题。在此之前，我们知道大学觉得再多找出几个那样的bug值不值？
        向决策者报告
            
    捕获有智慧的结晶
        探索者所发现的最有价值信息当中，有一些是关于如何有效探索的。要重视去寻找可供其他对应使用的信息
'''



##4.附录-测试启发速查表
'''
通用启发法（适用于任何种类的接口和任何种类的系统）
    抽象
        剔除细节，提升抽象层级
    绝不和始终
    开始，中间，结束
        观察那些因位置改变而导致的迹象
    集中一切
        如果事物散落，就放在同一地方
    改变模型
        一种不同的呈现形式来描绘你所测系统的模型
            状态图<-->表格（状态是列，事件是行）
        线性钢要<-->思维导图
    CRUD(增删改查）
        结合“开始，中间，结束”
        结合“0，单，多”
    分散一切
    跟随数据
    金发女孩
        无效的错误信息
        删减大量数据却不通告
        保存数据失败却不做通告
    干扰
    逆向
    部分，全无，全部
    挨饿
    过少
    过多
    有效近似值
    违反数据格式规则
    零，单，多
    变焦
        注重具体细节，必要时收窄视野    
    

'''